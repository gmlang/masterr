---
layout: post
title: "On Recursion - Part 2"
date: 2017-07-06
comments: true
categories: r
keywords: "R, recursion, recusive functions in R, environment, recursing over environments in R, where(), exists(), tail recursion"
published: true
share: true
ads: true
---

In the [*Environments*](http://adv-r.had.co.nz/Environments.html#env-recursion) chapter of the book *Advanced R*, Hadley presented a function 
`where(name, env = parent.frame())` that finds the first environment where a given name is defined. The parameter `env` is the environment where the search begins. Its default value is the global environment (the environment where we normally work). The function was written recursively. I encourage you to study it first before reading on because I'm giving a solution here to one of the exercises, which asks to write a recursive function to find all environments that contain a binding for `name`. 

Here's my solution. 

```{r}
where_all = function(name, env = parent.frame()) {
        # Finds all environments that contain a binding for name.
        # 
        # name: string, name of an object
        # env : environment object where the search begins
        
        if (identical(env, emptyenv())) { # base case
                res = NULL
        } else { # non-base case
                if (exists(name, envir = env, inherits = F)) { # success case
                        res = env
                } else { # fail case
                        res = NULL
                }
                        
                # recursive step
                c(res, where_all(name, parent.env(env)))
        }
}
```

Let's test it.

```{r}
# test
mean = function(x) "guck"
where_all("mean")
```

Now inside of `where_all()` I used a base R function `exists()` to check if `name` is in the current environment. But we don't have to use it, instead, we can implement our own version using recursion. Below is how to do it.

```{r}
exists2 = function(name, env=parent.frame(), inherits = T) {
        # Checks is name is in the given environment or its parent environments.
        # 
        # name: string, name of an object
        # env : environment object where the search begins
        # inherits: logical

        if (inherits) {
                if (identical(env, emptyenv())) { # base case
                        FALSE
                } else { # non-base case
                        if (name %in% ls(env)) { # success case
                                TRUE
                        } else { # fail case
                                # recursive step
                                exists2(name, parent.env(env)) 
                        }
                }        
        } else {
                name %in% ls(env)
        }
}
```

We can simplify the code a bit by collapsing the `if...else...` inside the non-base case with the outside `else` clause. This makes the code a bit easier to read.

```{r}
exists2 = function(name, env=parent.frame(), inherits = T) {
        # Checks is name is in the given environment or its parent environments.
        # 
        # name: string, name of an object
        # env : environment object where the search begins
        # inherits: logical
        
        if (inherits) {
                if (identical(env, emptyenv())) { # base case
                        FALSE
                } else if (name %in% ls(env)) { # success case
                        TRUE
                } else { # fail case
                        exists2(name, parent.env(env)) # recursive step
                }
        } else {
                name %in% ls(env)
        }
}
```

Let's test it out.

```{r}
e = new.env()
e$x = 109
e$y = 83
rm("x", envir=e)
exists2("y", env=e)
exists2("y")
exists2("x", env=e)
ls(e)
```

Take a moment to compare `exists2()` and `where_all()`. Where does the recursive step happen? In `exists2()`, it happens when the fail case is triggered. But in `where_all()`, it happens after both the success and fail cases. So the take away is that although all recursions are the same in concept but they can differ in implementation. The key difference lies in where the recursive step happens.


