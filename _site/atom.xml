<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-08-15T14:26:37+09:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Become Great at R</title><subtitle>Mastering the R programming language</subtitle><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><entry><title type="html">RFP - Part 9: Local Functions and Local Variables</title><link href="http://localhost:4000/r/RFP-part9-functions02/" rel="alternate" type="text/html" title="RFP - Part 9: Local Functions and Local Variables" /><published>2019-04-15T00:00:00+09:00</published><updated>2019-04-15T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part9-functions02</id><content type="html" xml:base="http://localhost:4000/r/RFP-part9-functions02/"><![CDATA[<p>A common thing to do in functional programming is to create, within a (outer) function, a local (inner) function that uses other variables in scope. Let me give you an example. The function <code class="language-plaintext highlighter-rouge">countup_from1()</code> uses a local helper function <code class="language-plaintext highlighter-rouge">count()</code> to accumulate results recursively. Its argument <code class="language-plaintext highlighter-rouge">x</code> is used directly inside <code class="language-plaintext highlighter-rouge">count()</code>.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">countup_from1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># x: integer</span><span class="w">
        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># from: integer</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1"># can use x because count() is local</span><span class="w">
                </span><span class="k">else</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">(</span><span class="n">from</span><span class="m">+1</span><span class="p">))</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="n">count</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">countup_from1</span><span class="p">(</span><span class="m">10</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre></figure>

<p>Another common thing to do is to make local variables to store the results of expensive computations. Before I give you an example, let’s first define some helper functions.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Check if a vector is empty. Returns TRUE if it is, FALSE otherwise.</span><span class="w">
</span><span class="n">is_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="nf">length</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the first element of a vector, raising an exception if the vector is empty.</span><span class="w">
</span><span class="n">hd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Vector is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the tail of a vector without its first element, raising an exception if the vector is empty.</span><span class="w">
</span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Vector is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[</span><span class="m">-1</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Using these helpers, we can write a function that returns the max value of an integer vector. Without using local variables to store intermediate results, <code class="language-plaintext highlighter-rouge">bad_max()</code> gets very expensive even for small-lengthed input vectors.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">bad_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: integer vector</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="m">0</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bad_max</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="c1"># recursive call to bad_max()</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">bad_max</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="c1"># recursive call to bad_max(), these two recursive</span><span class="w">
                             </span><span class="c1"># calls hugely slow down the computation.</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">bad_max</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 10</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">bad_max</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">20</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 20</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># bad_max(1:30) # this will take "forever"!</span></code></pre></figure>

<p>We can re-write the function by using a local variable to store the
intermediate result of the expensive recursive step.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">good_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="m">0</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">tl_ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">good_max</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="c1"># use local variable to store expensive computation</span><span class="w">
                </span><span class="n">hd_xs</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> 
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hd_xs</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tl_ans</span><span class="p">)</span><span class="w"> </span><span class="n">hd_xs</span><span class="w">
                </span><span class="k">else</span><span class="w"> </span><span class="n">tl_ans</span><span class="w">
        </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">good_max</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">30</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 30</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">good_max</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">100</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 100</code></pre></figure>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[A common thing to do in functional programming is to create, within a (outer) function, a local (inner) function that uses other variables in scope. Let me give you an example. The function countup_from1() uses a local helper function count() to accumulate results recursively. Its argument x is used directly inside count().]]></summary></entry><entry><title type="html">RFP - Part 8: R Functions</title><link href="http://localhost:4000/r/RFP-part8-functions01/" rel="alternate" type="text/html" title="RFP - Part 8: R Functions" /><published>2019-04-03T00:00:00+09:00</published><updated>2019-04-03T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part8-functions01</id><content type="html" xml:base="http://localhost:4000/r/RFP-part8-functions01/"><![CDATA[<p>Functions play a quintessential role in R. 
John Chambers said that “in R: everything that happens is a function call.”
Before diving into R functions, I want to explain the mathematical concept of 
“function” because it will help us understand R functions.</p>

<p>A mathematical function is made of input variables and a body of mathematical
statements operating on the input variables. Once defined, it can be used again
and again, taking on different input values and returning some values as output.<br />
But for the same inputs, a math function always outputs the same answer. 
For example, consider the identity function <code class="language-plaintext highlighter-rouge">f(x) = x</code> defined over the real 
numbers. We have</p>

<ul>
  <li>the value of <code class="language-plaintext highlighter-rouge">f(1)</code> is always 1,</li>
  <li>the value of <code class="language-plaintext highlighter-rouge">f(-100.1)</code> is always -100.1, and</li>
  <li>in general, the value of <code class="language-plaintext highlighter-rouge">f(x)</code> is always <code class="language-plaintext highlighter-rouge">x</code> for any real number <code class="language-plaintext highlighter-rouge">x</code>.</li>
</ul>

<p>A pure function in programming is analogous to a math function. A pure function 
never changes the input data, and always makes a new copy and modifies the copy. 
Functional programming (FP) encourages the usage of pure functions because they 
make it easier to reason about what’s going on. In R, if you want to write pure
functions (and most of the time you want to do that), avoid the <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> assignment
operator<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>.</p>

<p>Similar to a math function, a R function also has a list of input arguments and 
a body. The following code chunck presents a example template for defining a 
function in R. The keyword <code class="language-plaintext highlighter-rouge">function</code> tells R that we’re defining a function. 
Its input arguments are <code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2 = 5</code> and <code class="language-plaintext highlighter-rouge">...</code>, with 5 being the default value 
of <code class="language-plaintext highlighter-rouge">x2</code>. The <code class="language-plaintext highlighter-rouge">...</code> argument is special and can contain any number of arguments. 
It is used when the number of arguments are unknown or when the unknown 
arguments will be passed on to another function inside the function. The braces 
<code class="language-plaintext highlighter-rouge">{}</code> sourounds the function body, which is just a bunch of R statements and 
expressions involving the input variables (<code class="language-plaintext highlighter-rouge">x1</code>, <code class="language-plaintext highlighter-rouge">x2</code>, <code class="language-plaintext highlighter-rouge">...</code>). The function body
can be long or short.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># body content</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>However, R functions have something that math functions don’t have: an 
environment that was active when the function was created. Anything bound in
this environment are available to the function. So everytime we create a R 
function, what we see are the code we write down. When we send the code of 
the function to R for evaluation, R attaches an environment to the function.
This is something we don’t see but happens under the hood nonetheless. The 
combination of the code of the function and the bindings in its environment is 
called a “function closure.” The word “closure” emphasizes the attached 
environment.</p>

<p>After a R function is created, we want to use it by calling it over some input 
values. When a R function is called, a new environment (named the <em>calling</em> or 
<em>evaluation environment</em>) is created, whose parent environment (also called 
<em>enclosure</em>) is the environment from the function closure. The calling 
environment is initially populated with the unevaluated arguments of the 
function. As evaluation proceeds, symbols are searched from the calling 
environment first and then from its parent, and local variables are created 
inside the calling environment.</p>

<p>The above explanation is a little abstract. Read the following post for a 
example that will help contextualizing things:</p>

<p><a href="https://masterr.org/r/understand-r-environments-part1/">Understand R Environments</a></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>This <a href="https://masterr.org/r/RFP-part6/">article</a> explains how <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> works. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Functions play a quintessential role in R. John Chambers said that “in R: everything that happens is a function call.” Before diving into R functions, I want to explain the mathematical concept of “function” because it will help us understand R functions.]]></summary></entry><entry><title type="html">RFP - Part 7: Well-behaved R Functions</title><link href="http://localhost:4000/r/RFP-part7-functions00/" rel="alternate" type="text/html" title="RFP - Part 7: Well-behaved R Functions" /><published>2019-03-25T00:00:00+09:00</published><updated>2019-03-25T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part7-functions00</id><content type="html" xml:base="http://localhost:4000/r/RFP-part7-functions00/"><![CDATA[<p>Function is a big topic in R programming. I’ll spend several blog posts talking 
about it. But before I dive into R functions with full force, I want to show you 
how nice it is to work with them. Consider the following code:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># Bind x to 1 in the global environment.</span><span class="w">
</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1"># Define a function to tell what value x maps to when we call it later.</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="c1"># Rebind x to 2 in the global environment.</span><span class="w">
</span><span class="c1"># ls(envir = globalenv()) # Check that x and f are indeed in the global environment.</span></code></pre></figure>

<p>When we call <code class="language-plaintext highlighter-rouge">f</code>, what will it return? Mathematically and intuitively, we’d expect 
<code class="language-plaintext highlighter-rouge">f</code> to return <code class="language-plaintext highlighter-rouge">2</code> because x has a value of 2 now (although it had a value of 1 before). 
If x takes a different value later, we’d expect <code class="language-plaintext highlighter-rouge">f</code> to return the new value when 
called later. In other words, we expect <code class="language-plaintext highlighter-rouge">f</code>, when called, to return the current 
x value. This is exactly what <code class="language-plaintext highlighter-rouge">f</code> does in R:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">f</span><span class="p">()</span><span class="w">   </span><span class="c1"># Calling f returns 2 because x is 2</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 2</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="c1"># Rebind x to 3</span><span class="w">
</span><span class="n">f</span><span class="p">()</span><span class="w">   </span><span class="c1"># Calling f returns 3 because x is 3 now</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 3</code></pre></figure>

<p>So R evaluation rules<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, by and large, mimic mathematical or intuitive reasonings 
pretty well. As a result, we often don’t come across surprises when coding in R. 
Don’t take this for granted. Not every programming language behave this way. For 
example, if you try to do the same thing in SML, you’ll be surprised by 
what you get. See the following SML code with detailed comments:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = 1; (* Create an environment, and inside this environment, x is bound to 1.*)
fun f () = x; (* Define a function that when we call it later, it tells us what value x is bound to. *)
val x = 2; (* Create a different environment, and inside this new environment, x is bound to 2. *)
x; (* The later binding for x shadows the earlier one, so calling x returns 2. *)
f(); (* Calling f returns 1, NOT 2! This has to do with SML's evaluation rule. *)
</code></pre></div></div>

<p>In SML, how a binding is evaluated depends on (roughly) the values of the 
<strong>preceding</strong> bindings. Prior to the function binding (i.e., when <code class="language-plaintext highlighter-rouge">f</code> is defined), 
<code class="language-plaintext highlighter-rouge">x</code> was bound to 1, so evaluating the function binding (i.e., calling <code class="language-plaintext highlighter-rouge">f</code>) 
returns 1 not 2. In other words, in SML, <code class="language-plaintext highlighter-rouge">f</code> always returns the last value x was
bound to before <code class="language-plaintext highlighter-rouge">f</code> was defined.</p>

<p>Let’s all take a moment to appreciate the nice behavior of R functions.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Read this <a href="https://masterr.org/r/understand-r-environments-part1/">article</a> to understand exactly how code are evaluted in R. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Function is a big topic in R programming. I’ll spend several blog posts talking about it. But before I dive into R functions with full force, I want to show you how nice it is to work with them. Consider the following code:]]></summary></entry><entry><title type="html">RFP - Part 6: R «- Assignment Operator</title><link href="http://localhost:4000/r/RFP-part6/" rel="alternate" type="text/html" title="RFP - Part 6: R «- Assignment Operator" /><published>2019-03-10T00:00:00+09:00</published><updated>2019-03-10T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part6-%3C%3C-</id><content type="html" xml:base="http://localhost:4000/r/RFP-part6/"><![CDATA[<p>If you have been following this R Functional Programming (RFP) series<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, you know by now we have discussed:</p>

<ul>
  <li><a href="https://masterr.org/r/RFP-part3-variables/">how regular assignment operators <code class="language-plaintext highlighter-rouge">&lt;-</code>/<code class="language-plaintext highlighter-rouge">=</code> work in R</a>, and</li>
  <li><a href="https://masterr.org/r/RFP-part5-immutability/">how “copy n modify” works in R</a>.</li>
</ul>

<p>In summary, we have the following facts about the R language:</p>

<ul>
  <li>Variable assignment binds symols to objects.</li>
  <li>Reassignment changes the binding. It doesn’t modify data.</li>
  <li>Mutability is a property of objects. It has nothing to do with variables or variable assignment.</li>
  <li>Copy-n-modify is everywhere.</li>
</ul>

<p>To better understand these facts, let’s walk through two examples. The first example consists
of the following code block:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">change</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">5</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"do work and get:"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"start          :"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
        
        </span><span class="n">change</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1"># x is not changed. It still points to the same value 5</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"end            :"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>What will happen if we call <code class="language-plaintext highlighter-rouge">main()</code>?</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">x</code> will be bound to 5.</li>
  <li>5 and its memory address will be printed.</li>
  <li><code class="language-plaintext highlighter-rouge">change(x)</code> will not change the value of <code class="language-plaintext highlighter-rouge">x</code>.</li>
  <li>5 and the same address will be printed.</li>
</ol>

<p>Let’s call it now:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">main</span><span class="p">()</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "start          : 5 at addr 0x7f875baea088"
## [1] "do work and get: 0 at addr 0x7f875ebda4e8"
## [1] "end            : 5 at addr 0x7f875baea088"</code></pre></figure>

<p>The output confirms our reasoning. When the line <code class="language-plaintext highlighter-rouge">change(x)</code> is executed, a new 
environment is created, then the value 5 is copied into this new environment and 
bound to a new variable <code class="language-plaintext highlighter-rouge">x</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. When the line <code class="language-plaintext highlighter-rouge">x = x - 5</code> is run, 
R looks up the value 5 of this new <code class="language-plaintext highlighter-rouge">x</code> from this new environment, carries out the 
subtraction and rebinds <code class="language-plaintext highlighter-rouge">x</code> to the result 0. When the program steps out of the 
function <code class="language-plaintext highlighter-rouge">change()</code>, everything (<code class="language-plaintext highlighter-rouge">x</code>, 0, 5) inside of this new environment will 
be garbage collected. I want to point out that the original <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">main()</code> is 
never modified. See the following diagram:</p>

<p><img src="../../figs/2019-03-10-RFP-part6-&lt;&lt;-/change-outside-main.png" alt="" /></p>

<h2 id="--reassigns-variables-in-outer-scope"><code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> Reassigns Variables in Outer Scope</h2>

<p>Now let’s look at the second example:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">change</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">5</span><span class="w">
                </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"do work and get:"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
        </span><span class="p">}</span><span class="w">
        
        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"start          :"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
        
        </span><span class="n">change</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1"># x is changed. It now points to a new value 0 at a different location </span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"end            :"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at addr"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>This example differs from the first one at two places:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">change()</code> is defined inside of <code class="language-plaintext highlighter-rouge">main()</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> is used instead of <code class="language-plaintext highlighter-rouge">&lt;-</code> or <code class="language-plaintext highlighter-rouge">=</code> (<code class="language-plaintext highlighter-rouge">x &lt;&lt;- x - 5</code> instead of <code class="language-plaintext highlighter-rouge">x = x - 5</code>).</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> operator is usually only used in functions. While operators <code class="language-plaintext highlighter-rouge">&lt;-</code> and <code class="language-plaintext highlighter-rouge">=</code> perform variable assignment inside the environment (or scope) where they are evaluated, <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> causes a search through parent environments for the variable being assigned. If such a variable is found (and its binding is not locked) then its value is redefined, otherwise assignment takes place in the global environment. 
I’d like to point out that like <code class="language-plaintext highlighter-rouge">&lt;-</code> and <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> also only changes the binding and doesn’t modify data.</p>

<p>In this example:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">change()</code> defines an inner scope and <code class="language-plaintext highlighter-rouge">main()</code> defines an outer scope.</li>
  <li>because of <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code>, <code class="language-plaintext highlighter-rouge">change(x)</code> changes the value of <code class="language-plaintext highlighter-rouge">x</code> defined in the outer scope.</li>
</ul>

<p>When we call <code class="language-plaintext highlighter-rouge">main()</code>, the following will happen:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">change</code> will be bound to <code class="language-plaintext highlighter-rouge">function(x) { x &lt;&lt;- x - 5 ...}</code> in the outer scope.</li>
  <li><code class="language-plaintext highlighter-rouge">x</code> will be bound to 5 in the outer scope.</li>
  <li>5 and its memory address will be printed.</li>
  <li><code class="language-plaintext highlighter-rouge">change(x)</code> will change the value of outer <code class="language-plaintext highlighter-rouge">x</code> to 0 and print 5 and a different location.</li>
  <li>5 and yet another different location will be printed.</li>
</ol>

<p>Let’s call <code class="language-plaintext highlighter-rouge">main()</code> and look at the output:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">main</span><span class="p">()</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "start          : 5 at addr 0x7f875f47f810"
## [1] "do work and get: 5 at addr 0x7f875e8daa80"
## [1] "end            : 0 at addr 0x7f875fcd4340"</code></pre></figure>

<p>The 2nd line of output is particularly interesting. You’re probably expecting it 
to print 0, but that wouldn’t be correct. When the line <code class="language-plaintext highlighter-rouge">change(x)</code> is executed, a new 
environment is created, then the value 5 is copied into this new environment and 
bound to a new variable <code class="language-plaintext highlighter-rouge">x</code><sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. When the line <code class="language-plaintext highlighter-rouge">x &lt;&lt;- x - 5</code> is run, R looks up 
the value 5 of this new <code class="language-plaintext highlighter-rouge">x</code> from this new environment, carries out the subtraction 
and rebinds <em>the <code class="language-plaintext highlighter-rouge">x</code> in the outer scope</em> to the result 0. Notice that the 
inner variable <code class="language-plaintext highlighter-rouge">x</code> is still bound to 5. When R executes the line
<code class="language-plaintext highlighter-rouge">print(paste("do work and get:", x, "at addr", pryr::address(x)))</code>, it looks up the
value and address of the inner <code class="language-plaintext highlighter-rouge">x</code>, and hence prints 5. Of course, because this 5 
is a copy of the outer 5, it is a different 5 and hence has a different memory address.
See the following diagram:</p>

<p><img src="../../figs/2019-03-10-RFP-part6-&lt;&lt;-/change-inside-main.png" alt="" /></p>

<p>To summarize, here’re the facts about <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code>:</p>

<ul>
  <li>it’s usually only used in functions.</li>
  <li>it reassigns outer variables by changing its binding.</li>
  <li>it never modifies data directly.</li>
</ul>

<p>Here’s an example of how <code class="language-plaintext highlighter-rouge">&lt;&lt;-</code> can be used in real world:</p>

<p><a href="https://masterr.org/r/understand-r-environments-part3/">Mortgage Payment Schedule Calculator</a></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>If you haven’t, I recommend you to read the linked posts first. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>different from the <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">main()</code>. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[If you have been following this R Functional Programming (RFP) series1, you know by now we have discussed: If you haven’t, I recommend you to read the linked posts first. &#8617;]]></summary></entry><entry><title type="html">RFP - Part5: Immutability in R</title><link href="http://localhost:4000/r/RFP-part5-immutability/" rel="alternate" type="text/html" title="RFP - Part5: Immutability in R" /><published>2019-02-15T00:00:00+09:00</published><updated>2019-02-15T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part5-immutability</id><content type="html" xml:base="http://localhost:4000/r/RFP-part5-immutability/"><![CDATA[<p>Do not confuse variable reassignment (or rebinding) with mutation. Reassignment in R changes the binding. (See the <a href="https://masterr.org/r/RFP-part4-shadowing/">second diagram</a> for an example.) Mutation changes the referenced object itself. R supports limited mutation by default and base R objects are mostly immutable. As a result, R code often behaves like what we’d expect it to behave mathematically. This allows the programmer to focus on the mathematical or statistical problem at hand without being distracted by the “computer side of things.” Indeed, if you’re trained as a mathematician or statistician without any programming experience, you’ll find it’s easier to write R code than most typical programming languages like Python, Ruby, Java, C++, or Rust etc.</p>

<h2 id="r-objects-are-mostly-immutable">R objects are (mostly) immutable.</h2>

<p>Consider the following R code, where x and y refer to the same list initially. If we change any element of x, the value of y will not be automatically changed. This is exactly what we would expect mathematically.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> 
</span><span class="n">identical</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="c1"># x and y point to the same object</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="p">[[</span><span class="m">2</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># change the second element of x</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">   </span><span class="c1"># x is changed</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w">   </span><span class="c1"># y is not changed     </span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 1
## 
## [[2]]
## [1] 0
## 
## [[3]]
## [1] 1</code></pre></figure>

<p>The R code <code class="language-plaintext highlighter-rouge">x[[2]] = 1</code> gives the illusion of modifying the list referenced by x. Internally, it actually does two things: first create a modified copy of that list, then rebind x to the modified copy, leaving the original list unchanged. Because y is still bound to the original list, running <code class="language-plaintext highlighter-rouge">print(y)</code> will display the original list on screen. We summarize what’s going on in the following diagram:</p>

<p><img src="../../figs/2019-02-15-RFP-part5-immutability/immutable.png" alt="" /></p>

<p>If we do the same thing in Python, as shown in the code block below, we’ll discover that element change in x is also visible through y. This is often surprising to people without a formal training in programming. How could the value of y be changed when no operation was performed on y explicitly? The reason is because unlike lists in R, Python lists are mutable.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># change the second element of x, python list starts at index 0
</span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x is changed</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1, 1, 1]</code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="c1"># y is also changed</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1, 1, 1]</code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># x and y still refer to the same list, with its 2nd element changed to 1</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## True</code></pre></figure>

<p>The python code <code class="language-plaintext highlighter-rouge">x[1] = 1</code> directly modifies the list referenced by x, updating its second element to a value of 1. There’s no new list being created. Both x and y are still bound to the original list, which has the value of its second element changed from 0 to 1. This can be seen pictorially as follows:</p>

<p><img src="../../figs/2019-02-15-RFP-part5-immutability/mutable.png" alt="" /></p>

<h2 id="copy-on-modify-if-necessary">Copy on modify (if necessary)</h2>

<p>Detailed oriented readers probably have noticed the title of the previous section has the word “mostly” in parenthesis: “R objects are (mostly) immutable.” The implication is that some R objects (for example, lists and vectors) can also be mutable sometimes. Consider the following example, where there’s only one variable x pointing to the list [-1, 0, 1]. Because there are no other variables that refer to the same list, updating any element of x will directly modify the list instead of making a modified copy.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="p">{</span><span class="w"> </span><span class="c1"># must use curly brackets to group code if running in Rstudio. No need of them if running inside of R directly.</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w">
        </span><span class="n">x</span><span class="p">[[</span><span class="m">2</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w">
        </span><span class="n">x</span><span class="p">[[</span><span class="m">3</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-9</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="c1"># identical memory addresses show there was no rebinding and x always point to the same list. So it's the list itself that gets modified.</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "0x7f8207893e48"
## [1] "0x7f8207893e48"
## [1] "0x7f8207893e48"</code></pre></figure>

<p>Consider another example where we first assign the vector <code class="language-plaintext highlighter-rouge">1:13</code> to a variable v then change v’s elements:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="p">{</span><span class="w"> </span><span class="c1"># must use curly brackets to group code if running in Rstudio. No need of them if running inside of R directly.</span><span class="w">
        </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">13</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w">
        </span><span class="n">v</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="w">  </span><span class="c1"># makes a modified copy</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="c1"># different memory address, indicating modified copy</span><span class="w">
        </span><span class="n">v</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-100</span><span class="w"> </span><span class="c1"># modify the copy directly</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="c1"># same memory address, indicating direct modification</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "0x7f81fff33fc8"
## [1] "0x7f82057bfa98"
## [1] "0x7f82057bfa98"</code></pre></figure>

<p>Although there’s no other variables pointing to the same vector, the first time we tried to change v’s elements (<code class="language-plaintext highlighter-rouge">v[1] = 100</code>), R made a modified copy. When we tried to change v’s elements for the second time (<code class="language-plaintext highlighter-rouge">v[2] = -100</code>), R didn’t make another modified copy, instead, R modified the modified copy directly.</p>

<p>In summary, it seems R is smart to know when to directly modify an object and when to make a modified copy. How does R do it? Well, it turns out that R implements something called “copy on modify (if necessary),” which means that copying is done only when we try to modify an object, and if the modification has no “spillover effects” (for example, making the value of other variables or non-local variables changed), R will just modify without copying.</p>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Do not confuse variable reassignment (or rebinding) with mutation. Reassignment in R changes the binding. (See the second diagram for an example.) Mutation changes the referenced object itself. R supports limited mutation by default and base R objects are mostly immutable. As a result, R code often behaves like what we’d expect it to behave mathematically. This allows the programmer to focus on the mathematical or statistical problem at hand without being distracted by the “computer side of things.” Indeed, if you’re trained as a mathematician or statistician without any programming experience, you’ll find it’s easier to write R code than most typical programming languages like Python, Ruby, Java, C++, or Rust etc.]]></summary></entry><entry><title type="html">RFP - Part4: R Variable Shadowing</title><link href="http://localhost:4000/r/RFP-part4-shadowing/" rel="alternate" type="text/html" title="RFP - Part4: R Variable Shadowing" /><published>2019-02-14T00:00:00+09:00</published><updated>2019-02-14T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part4-shadowing</id><content type="html" xml:base="http://localhost:4000/r/RFP-part4-shadowing/"><![CDATA[<p>Now we know that R variables are objects, and that they can be manipulated, assigned any R objects and reassigned.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> (detailed discussion <a href="https://masterr.org/r/RFP-part3-variables/">here</a>.) We’ll discuss variable shadowing and its difference from variable reassignment.</p>

<h2 id="variable-reassignment-in-r">Variable reassignment in R</h2>

<p>After we assign a R object to a variable, the variable will refer to that object. Let’s use a gray rectangular shape to represent the variable, and draw an arrow from the variable pointing to the object. For example, here is what’s going on behind the one-liner <code class="language-plaintext highlighter-rouge">x = 3</code> pictorially:</p>

<p><img src="../../figs/2019-02-14-RFP-part4-shadowing/var-binding.png" alt="" /></p>

<p>When a variable is reassigned another object, it won’t refer to the original object anymore. We represent this by changing the original solid arrow to a dashed one. A new solid arrow is drawn from the variable pointing to the new object. For example, the following diagram shows what happens if we reassign x to 32 (<code class="language-plaintext highlighter-rouge">x = 32</code>):</p>

<p><img src="../../figs/2019-02-14-RFP-part4-shadowing/var-rebinding.png" alt="" /></p>

<p>The above diagrams depict how variable assignment and reassignment work in both R and Python. Before we talk about how variable shadowing works in R, let’s take a look at how it works in an old programing language called Standard ML (SML).</p>

<h2 id="variable-shadowing-in-sml">Variable shadowing in SML</h2>

<p>SML doesn’t have variable reassignment or rebinding. For example, consider the same mathematical operation of first setting x to 3 and then to 32. Its SML code is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val x = 3;  (* create an environment and inside it bind x to 3*)
val x = 32; (* create a different environment and inside this new environment bind x to 32 *)
</code></pre></div></div>

<p>The following diagram captures what happens when we run the SML code:</p>

<p><img src="../../figs/2019-02-14-RFP-part4-shadowing/var-shadowing.png" alt="" /></p>

<p>The second x is a new variable different from the first x! It shadows the first x. As a result, if we print x we’d get 32. So the mathematical reassignment operation is carried out by variable shadowing in SML.</p>

<h2 id="variable-shadowing-in-r">Variable shadowing in R</h2>

<p>R also has variable shadowing, which happens if the same variable is assigned in different scopes. Reassignment happens if the same variable is assigned twice or more times in the same scope. Consider the following R code, where each function definition creates a new scope:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># global x</span><span class="w">
</span><span class="n">outer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"The Great Gatsby"</span><span class="w"> </span><span class="c1"># outer x</span><span class="w">
        
        </span><span class="n">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="w"> </span><span class="c1"># inner x</span><span class="w">
                </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"inner:"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
        </span><span class="p">}</span><span class="w">
        
        </span><span class="n">inner</span><span class="p">()</span><span class="w"> </span><span class="c1"># call function inner()</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"outer:"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> 
</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="w">
        </span><span class="n">outer</span><span class="p">()</span><span class="w"> </span><span class="c1"># call function outer()</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"global:"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "inner: TRUE"
## [1] "outer: The Great Gatsby"
## [1] "global: 0"</code></pre></figure>

<p>From the above printed output, we see the x inside <code class="language-plaintext highlighter-rouge">inner()</code> shadows the x between <code class="language-plaintext highlighter-rouge">inner()</code> and <code class="language-plaintext highlighter-rouge">outer()</code>, which further shadows the x outside of <code class="language-plaintext highlighter-rouge">outer()</code>. This can be seen more clearly from the following diagram:
<img src="/../figs/2019-02-14-RFP-part4-shadowing/unnamed-chunk-2-1.png" title="center" alt="center" style="display: block; margin: auto;" /></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>The terms “variable (re)assignment” and “variable (re)binding” are used interchangeably throughout this series because we use them for their mathematical meaning: (re)associate a symbol with a value. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Now we know that R variables are objects, and that they can be manipulated, assigned any R objects and reassigned.1 (detailed discussion here.) We’ll discuss variable shadowing and its difference from variable reassignment. The terms “variable (re)assignment” and “variable (re)binding” are used interchangeably throughout this series because we use them for their mathematical meaning: (re)associate a symbol with a value. &#8617;]]></summary></entry><entry><title type="html">RFP - Part3: R Variables</title><link href="http://localhost:4000/r/RFP-part3-variables/" rel="alternate" type="text/html" title="RFP - Part3: R Variables" /><published>2019-02-13T00:00:00+09:00</published><updated>2019-02-13T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part3-variables</id><content type="html" xml:base="http://localhost:4000/r/RFP-part3-variables/"><![CDATA[<p>Previously, we discussed two data structures in R: <a href="https://masterr.org/r/RFP-part1-vectors/">vectors</a> and <a href="https://masterr.org/r/RFP-part2-lists/">lists</a>. If you programmed in another language before, you probably already got a sense that R vectors and lists are a tiny bit different than what you’re used to. This is to be expected. In general, there is a nuanced difference between R data structures and that of many other languages.</p>

<p>The phrase “data structure” is often used to mean value containers (e.g., tupple, list, array, vector, matrix etc.). But it can also be used in a broad sense to refer to any data-like objects that can be manipulated. In many other programming languages or informal English, data structures contain values, and values have types (e.g. int or float), but data structures don’t have types. In R, we take the broader meaning, and for this reason, R data structures are called objects<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. R objects have types, but their types are different from data types (e.g. int or float) of most other languages. This can be best seen by example.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">In most other languages</th>
      <th style="text-align: left">In R</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">89 is an integer.</td>
      <td style="text-align: left">89 is an object of type integer vector with length 1.</td>
    </tr>
    <tr>
      <td style="text-align: left">“hello” is a string.</td>
      <td style="text-align: left">“hello” is an object of type character vector with length 1.</td>
    </tr>
    <tr>
      <td style="text-align: left">1:10 is a container of integer values.</td>
      <td style="text-align: left">1:10 is an object of type integer vector.</td>
    </tr>
    <tr>
      <td style="text-align: left">list(TRUE, 2.2) is a container of a logical and a float.</td>
      <td style="text-align: left">list(TRUE, 2.2) is an object of type list. Its first element is an object of type logical vector with length 1. Its second element is an object of type numeric vector with length 1.</td>
    </tr>
  </tbody>
</table>

<p>So vectors and lists are objects in R. In fact, not only vectors or lists, to quote John Chambers, “everything that exists (in R) is an object.”</p>

<h2 id="variables-or-variable-names-are-objects">Variables or (variable) names are objects.</h2>

<p>Variables in R are objects and have the type “symbol.” For example, we can <code class="language-plaintext highlighter-rouge">quote</code> a variable <code class="language-plaintext highlighter-rouge">x</code> or wrap <code class="language-plaintext highlighter-rouge">as.name</code> around a string <code class="language-plaintext highlighter-rouge">"my_var"</code> and then call <code class="language-plaintext highlighter-rouge">typeof</code> on them. In both cases, we’d get “symbol.”</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">typeof</span><span class="p">(</span><span class="nf">quote</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="c1"># use the function quote() to create a symbol</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "symbol"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">typeof</span><span class="p">(</span><span class="n">as.name</span><span class="p">(</span><span class="s2">"my_var"</span><span class="p">))</span><span class="w"> </span><span class="c1"># as.name() also creates a symbol. Note it takes in a string.</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "symbol"</code></pre></figure>

<p>Compare this with variables in other languages. In a statically typed language like SML or Rust, variables have data types like <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">f64</code> and etc. In a dynamically typed language like Python, variables have no types. R is also dynamically typed, even though its variables have a type<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>

<p>Because R variables are objects, they can be manipulated in the same way as vectors or lists. For example, we can capture the operation of adding two variables and evaluate it later.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">quote</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="c1"># capture (x + y) without evaluation.</span><span class="w">
</span><span class="n">typeof</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="c1"># the captured expression is itself an object, and has type "language".</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "language"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="c1"># give a value to x.</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-1</span><span class="w"> </span><span class="c1"># give a value to y.</span><span class="w">
</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="c1"># now x and y take on particular values, we can evaluate the captured expression (x + y) and get a result.</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 9</code></pre></figure>

<p>“Computing on the language” is a very powerful feature that many other languages don’t offer. Without it, the almighty <a href="https://www.tidyverse.org">tidyverse</a> would crumble. We’ll spend a lot more time talking about it in later parts of this series. For now, let’s focus on the common role of variables.</p>

<h2 id="variables-refer-to-objects">Variables refer to objects.</h2>

<p>Variables in R play the role of symbolic names<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>, and can be bound to any objects. Once a variable is bound to an object, it refers to that object.</p>

<p>For example, if we simply type 6 in the console, we’ll lose it the moment the cursor returns. This is annoying because we may want to do more things to it. The solution is to give it a name by putting a symbol on the left of the assignment operator <code class="language-plaintext highlighter-rouge">&lt;-</code> or <code class="language-plaintext highlighter-rouge">=</code><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> and the value 6 on the right.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6</span></code></pre></figure>

<p>Now the symbol “x” refers to the value 6. Whenever we want to do more things to that 6, we can just use x.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="c1"># prints 8</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 8</code></pre></figure>

<p>In other words, R variables are like math variables. If you’re coming from a math or science background, you may take this for granted and think this is how variables are in all programming languages. But that’s not the case. Many major programming languages make a distinction between “name” and “variable,” and between “name binding” and “variable assignment”. In those languages (for example, C, Java or Rust), a variable is more than a name, and consists of three parts: name, content box and memory location (of the content box). We can think of a variable in those languages as a carefully-stored bottle of wine, with the bottle (content box), the label (name), and the wine opener (memory address) all being part of the game. Using the wine opener, we can uncork the bottle, pour the wine out (if there’re any), and put in different wine. In contrast, a R variable is like a bottle label, while the refered object is like a bottle of wine. Given a bottle of wine, we can place one or more labels on the bottle. If it’s already labeled, we can replace the label with a different one, or we can take off the label and put it on another bottle. But we cannot open a bottle and change the wine because its wine opener isn’t provided<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.</p>

<p>To summarize, SML, C or Java programmers call the “bottle labeling” operation “name binding” and the “changing the wine” operation “variable assignment.” But math people make no such distinction because there’s no “changing the wine” operation in math. In math, “variable assignment” is “name binding” and vice versa, with “variable assignment” being the prefered term. Because R was originally designed for Statisticians and mathematicians, the phrase “variable assignment” is more frequently used in the R world.</p>

<p>The following table shows the different meaning of the same phrase “Variable Assignment” in R vs. many other major languages.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: left">In many major languages</th>
      <th style="text-align: left">In R</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">bottle labeling</td>
      <td style="text-align: left">Name Binding</td>
      <td style="text-align: left">Variable Assignment</td>
    </tr>
    <tr>
      <td style="text-align: left">opening the bottle and changing the wine</td>
      <td style="text-align: left">Variable Assignment</td>
      <td style="text-align: left">Doesn’t support this in base R</td>
    </tr>
  </tbody>
</table>

<h2 id="many-to-one-many-variables-can-refer-to-the-same-object">Many-to-one: Many variables can refer to the same object.</h2>

<p>An object can be assigned to one or many variables. (In other words, one or many names can be bound to the same object, or simply, an object can have many names, or more than one variables can refer to the same object.)</p>

<p>Given a variable <code class="language-plaintext highlighter-rouge">x</code>, we can use <code class="language-plaintext highlighter-rouge">pryr::address(x)</code> to find the memory location of the object that <code class="language-plaintext highlighter-rouge">x</code> points to. (If we’re lazy, we can simply say “the memory location of <code class="language-plaintext highlighter-rouge">x</code>.”) If two variables have the same memory addresses, we say they refer to the same object.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># bind the symbol x to a value 1</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1"># bind the symbol y to the same value 1</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="c1"># x and y are equal</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">identical</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="c1"># the memory location of the value that x points to is the same as the one that y points to, indicating both x and y point to the same value.</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<p>On the other hand, different variables can refer to different objects, but have the same value. For example in the code below, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> point to two different 1’s.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># bind x to 1</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># bind y to another 1</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="c1"># x and y are equal in value</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">identical</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="c1"># the memory location of x is different from that of y, indicating x and y point to different objects.</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] FALSE</code></pre></figure>

<h2 id="variables-can-be-reassigned">Variables can be reassigned.</h2>

<p>Variables can be reassigned an unlimited number of times. This allows us to use variables just like how we use them in math:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"x points to"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"located at:"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "x points to 6 located at: 0x7fc5d7e07a38"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># use x to compute a new value and reassign it to x</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"x stops pointing to the old value. It now points to"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at:"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "x stops pointing to the old value. It now points to 7 at: 0x7fc5d8823070"</code></pre></figure>

<p>R is dynamically typed, so any variable can refer to any object at any time. For example, a variable can be assigned an integer, and then a string, and then a list, and then a function.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Norwegian Wood"</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="s2">"well..."</span><span class="p">)))</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="o">^</span><span class="m">2</span></code></pre></figure>

<h2 id="variables-are-reassigned-independently-of-other-variables">Variables are reassigned independently of other variables.</h2>

<p>Variables are not magically linked when they refer to the same object. They are still separate and independent variables. As a result, reassigning one of them won’t reassign the other:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6</span><span class="w">
</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1"># both y and x refer to the same 6</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">identical</span><span class="p">(</span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"both x and y point to"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"located at:"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "both x and y point to 6 located at: 0x7fc5da625e80"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">9</span><span class="w"> </span><span class="c1"># reassign x a value 9</span><span class="w">
</span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"reassigned x, and x now points to"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"at:"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "reassigned x, and x now points to 9 at: 0x7fc5da625cf8"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="s2">"y still points to the old"</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="s2">"at:"</span><span class="p">,</span><span class="w"> </span><span class="n">pryr</span><span class="o">::</span><span class="n">address</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "y still points to the old 6 at: 0x7fc5da625e80"</code></pre></figure>

<h2 id="objects-cant-live-long-without-variables">Objects can’t live long without variables.</h2>

<p>An object has a fleeting life unless it’s assigned to at least one variable. This is because R implements “garbage collection”<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>. Internally, R keeps track of the number of variables each object is bound to<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>, and automatically cleans up objects that are not referenced at all. For example, when we reassign a variable, the old object it refered to will be garbage collected if it has no other references.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">rm</span><span class="p">(</span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ls</span><span class="p">())</span><span class="w"> </span><span class="c1"># remove all objects in the global environment</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"hello"</span><span class="w"> </span><span class="c1"># look at the Environment panel inside Rstudio: x is bound to "hello".</span><span class="w">
</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"world"</span><span class="w"> </span><span class="c1"># look at the Environment panel, notice x is bound to "world" now. The value "hello" is gone.</span></code></pre></figure>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>To avoid confusion, we’ll stop using the phrase “R data structures” and use “objects” or “R objects” instead. We’ll keep using the phrase “data structures” as how it’s commonly understood. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>For this reason, R is sometimes called weakly typed. But this detail is not important. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>It’s not a coincidence that R variables are designed to have type “symbol.” <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">=</code> and <code class="language-plaintext highlighter-rouge">&lt;-</code> are the same for all practical purpose according to <a href="https://developer.r-project.org/equalAssign.html">RCore</a>. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Base R doesn’t provide ways for programmers to directly access the computer’s memory. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Not all programming languages implement garbage collection. The Rust programming language is an example. It doesn’t have garbage collection. Instead, it uses ownership to ensure memory safety. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>The function <code class="language-plaintext highlighter-rouge">pryr::refs()</code> can be used for finding the number of references an object has, but I find its result don’t make much sense. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Previously, we discussed two data structures in R: vectors and lists. If you programmed in another language before, you probably already got a sense that R vectors and lists are a tiny bit different than what you’re used to. This is to be expected. In general, there is a nuanced difference between R data structures and that of many other languages.]]></summary></entry><entry><title type="html">RFP - Part2: R Lists</title><link href="http://localhost:4000/r/RFP-part2-lists/" rel="alternate" type="text/html" title="RFP - Part2: R Lists" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part2-lists</id><content type="html" xml:base="http://localhost:4000/r/RFP-part2-lists/"><![CDATA[<p>Previously, we discussed R vectors. We now turn to R lists. Like a vector, a R list can also grow or shrink. But unlike a vector, a R list can contain any R objects. For example, vectors, lists, functions, or environments can all be the elements of a list, and it’s perfectly okay to mix them in the same list.</p>

<h2 id="the-empty-list">The empty list</h2>

<p>The empty list, with syntax <code class="language-plaintext highlighter-rouge">list()</code>, has 0 elements. Indeed, if we call <code class="language-plaintext highlighter-rouge">length(list())</code>, we get 0.</p>

<h2 id="non-empty-lists">Non-empty lists</h2>

<p>We can make a list with <code class="language-plaintext highlighter-rouge">list(e1, ..., en)</code> where each expression<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <code class="language-plaintext highlighter-rouge">e</code> is evaluated to a R object. It’s more common to make a list with <code class="language-plaintext highlighter-rouge">c(e1, e2)</code>, called called “<code class="language-plaintext highlighter-rouge">e1</code> combined with <code class="language-plaintext highlighter-rouge">e2</code>,” where <code class="language-plaintext highlighter-rouge">e1</code> evaluates to a “list” and <code class="language-plaintext highlighter-rouge">e2</code> evaluates to another “list.” The result is a new list that starts with the elements in <code class="language-plaintext highlighter-rouge">e1</code> followed by the elements in <code class="language-plaintext highlighter-rouge">e2</code>. In the simpler case when <code class="language-plaintext highlighter-rouge">e1</code> evaluates to a single value like 5, 1.2, “hello”, TRUE or NA, <code class="language-plaintext highlighter-rouge">c(e1, e2)</code> can also be called “<code class="language-plaintext highlighter-rouge">e1</code> consed onto <code class="language-plaintext highlighter-rouge">e2</code>.” The result is then a new list that starts with the value of <code class="language-plaintext highlighter-rouge">e1</code> followed by the elements in <code class="language-plaintext highlighter-rouge">e2</code>. Here’re some examples of lists:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="nf">list</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">3L</span><span class="p">)</span><span class="w"> </span><span class="c1"># each element is an integer</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"gm"</span><span class="p">,</span><span class="w"> </span><span class="s2">"lang"</span><span class="p">))</span><span class="w"> </span><span class="c1"># each element is a length-2 vector of diff. type</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 1 2
## 
## [[2]]
## [1] "gm"   "lang"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="nf">list</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="m">+1</span><span class="p">,</span><span class="w"> </span><span class="n">environment</span><span class="p">())</span><span class="w"> </span><span class="c1"># 1st element is a list, 3rd element is a function, 4th element is an env object</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [[1]][[1]]
## [1] 1
## 
## [[1]][[2]]
## [1] 2
## 
## 
## [[2]]
## [1] TRUE
## 
## [[3]]
## function (x) 
## x + 1
## 
## [[4]]
## &lt;environment: R_GlobalEnv&gt;</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># cons 9 onto the list(3, 6)</span><span class="w">
</span><span class="nf">c</span><span class="p">(</span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">))</span><span class="w"> </span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 9
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 6</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># list(1, list(2, 3)) is different from list(1, 2, 3)</span><span class="w">
</span><span class="o">!</span><span class="n">identical</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)),</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># list(1, list(2, 3)) is different from list(list(1, 2), 3))</span><span class="w">
</span><span class="o">!</span><span class="n">identical</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)),</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<h2 id="how-to-use-lists">How to use lists</h2>

<p>Once again, powered by recursion, we only need three simple operations when working with lists:</p>

<ol>
  <li>Check if a list is empty.</li>
  <li>Get the first element of a list, raising an exception if the list is empty.</li>
  <li>Get the tail of a list without its first element, raising an exception if the list is empty.</li>
</ol>

<p>Like in the case of vectors, R doesn’t provide these operations perfectly out of the box. So we need to write them ourselves:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Returns TRUE if a list is empty, FALSE otherwise.</span><span class="w">
</span><span class="n">is_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a list </span><span class="w">
        </span><span class="nf">length</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the first element of a list, raising an exception if the list is empty.</span><span class="w">
</span><span class="n">hd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a list </span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"List is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="w"> 
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the tail of a list without its first element, raising an exception if the list is empty.</span><span class="w">
</span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a list </span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"List is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[</span><span class="m">-1</span><span class="p">]</span><span class="w"> 
</span><span class="p">}</span></code></pre></figure>

<p>Having defined <code class="language-plaintext highlighter-rouge">is_empty()</code>, <code class="language-plaintext highlighter-rouge">hd()</code> and <code class="language-plaintext highlighter-rouge">tl()</code>, we can use them inside of recursive functions to perform complex operations on lists. For example, given a list of integer pairs, we can write a function to sum them up.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">sum_pair_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># xs: a list of interger pairs represented by length-2 vectors c(i1, i2)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="m">0</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum_pair_list</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">sum_pair_list</span><span class="p">(</span><span class="nf">list</span><span class="p">())</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 0</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">sum_pair_list</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 10</code></pre></figure>

<p>Or we can write functions to put the first or second element of each pair into separate lists.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">firsts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># xs: a list of interger pairs represented by length-2 vectors c(i1, i2)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="nf">list</span><span class="p">()</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">firsts</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">seconds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># xs: a list of interger pairs represented by length-2 vectors c(i1, i2)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="nf">list</span><span class="p">()</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)[</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">seconds</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">firsts</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 1
## 
## [[2]]
## [1] 3</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">seconds</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [[1]]
## [1] 2
## 
## [[2]]
## [1] 4</code></pre></figure>

<p>It should make us cringe that <code class="language-plaintext highlighter-rouge">firsts()</code> and <code class="language-plaintext highlighter-rouge">seconds()</code> look almost identical yet we wrote them as two different functions. We’ll learn how to fix it later. Notice that <code class="language-plaintext highlighter-rouge">is_empty()</code>, <code class="language-plaintext highlighter-rouge">hd()</code> and <code class="language-plaintext highlighter-rouge">tl()</code> defined above are very similarly to the ones defined in <a href="https://masterr.org/r/RFP-part1-vectors/">part1 of this series when we discussed R vectors</a>. This is because lists are just a special kind of vectors in R. To see this, realize that another way of declaring an empty list is <code class="language-plaintext highlighter-rouge">vector("list")</code>.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">identical</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="s2">"list"</span><span class="p">),</span><span class="w"> </span><span class="nf">list</span><span class="p">())</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] TRUE</code></pre></figure>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>The word ‘expression’ here is being used in the sense of expressions in any programming language or mathematical expressions. Do NOT confuse it with the R expression object. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[Previously, we discussed R vectors. We now turn to R lists. Like a vector, a R list can also grow or shrink. But unlike a vector, a R list can contain any R objects. For example, vectors, lists, functions, or environments can all be the elements of a list, and it’s perfectly okay to mix them in the same list.]]></summary></entry><entry><title type="html">RFP - Part1: R Vectors</title><link href="http://localhost:4000/r/RFP-part1-vectors/" rel="alternate" type="text/html" title="RFP - Part1: R Vectors" /><published>2019-02-11T00:00:00+09:00</published><updated>2019-02-11T00:00:00+09:00</updated><id>http://localhost:4000/r/RFP-part1-vectors</id><content type="html" xml:base="http://localhost:4000/r/RFP-part1-vectors/"><![CDATA[<p>The simplest data structure in R is the vector. A vector is one dimensional and can be imagined as a sequence of blocks containing values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    | v1 | v2 | ... |
</code></pre></div></div>

<p>A R vector can have any length. Its elements must have the same data type. (We’ll see later that each element is itself a length-1 vector.) There are four common types: logical, integer, double (also called numeric), and character. A vector is numeric if and only if its elements are doubles. Similarly, a logical vector has <code class="language-plaintext highlighter-rouge">TRUE</code> or <code class="language-plaintext highlighter-rouge">FALSE</code> as its elements. An integer vector contains only integers, and a character vector has only strings. Given a vector <code class="language-plaintext highlighter-rouge">x</code>, we can call <code class="language-plaintext highlighter-rouge">typeof(x)</code> to find its type.</p>

<h2 id="empty-vectors">Empty vectors</h2>

<p>There’s an empty vector for each type, with the following syntax:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">logical()</code></li>
  <li><code class="language-plaintext highlighter-rouge">integer()</code></li>
  <li><code class="language-plaintext highlighter-rouge">numeric()</code></li>
  <li><code class="language-plaintext highlighter-rouge">character()</code></li>
</ul>

<p>An empty vector has 0 elements and 0 length.</p>

<h2 id="length-1-vectors">Length-1 vectors</h2>

<p>Unlike most other programming languages, R doesn’t have scalar types or values (or as I like to call them, singletons). What appear as singletons are really just vectors of length one. For example, literals like <code class="language-plaintext highlighter-rouge">TRUE</code>, <code class="language-plaintext highlighter-rouge">1L</code>, <code class="language-plaintext highlighter-rouge">3.124</code>, <code class="language-plaintext highlighter-rouge">"R is awesome"</code> are vectors of length 1, and each has a different type. Constants like <code class="language-plaintext highlighter-rouge">NA</code>, <code class="language-plaintext highlighter-rouge">NA_integer_</code>, <code class="language-plaintext highlighter-rouge">NA_real_</code> and <code class="language-plaintext highlighter-rouge">NA_character_</code> are also vectors of length 1, where <code class="language-plaintext highlighter-rouge">NA</code> has type logical even though it’s not written explicitly like the others.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">print_atom_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># Prints the type and length of an atomic/single value. </span><span class="w">
        </span><span class="c1"># Shows atomic/singleton values are really just vectors of length 1.</span><span class="w">
        </span><span class="c1">#</span><span class="w">
        </span><span class="c1"># x: an atomic/singleton value such as 1L, "R is awesome", NA and etc.</span><span class="w">
        </span><span class="n">data_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">
        
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">is.finite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"integer"</span><span class="p">)</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"L"</span><span class="p">)</span><span class="w">
                </span><span class="k">else</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">is.nan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">is.infinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">is.na</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> 
                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"logical"</span><span class="p">)</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"integer"</span><span class="p">)</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"NA_integer_"</span><span class="w">
                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"double"</span><span class="p">)</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"NA_real_"</span><span class="w">
                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"character"</span><span class="p">)</span><span class="w"> </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"NA_character_"</span><span class="w">
                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># x must be a string</span><span class="w">
                        </span><span class="n">x_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paste0</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s2">"'"</span><span class="p">)</span><span class="w">   
                </span><span class="p">}</span><span class="w">        
        </span><span class="p">}</span><span class="w">
                
        </span><span class="n">print</span><span class="p">(</span><span class="n">paste</span><span class="p">(</span><span class="n">x_str</span><span class="p">,</span><span class="w"> </span><span class="s2">"is a vector of type"</span><span class="p">,</span><span class="w"> </span><span class="n">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> 
                    </span><span class="s2">"and length"</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># literals are vectors of length 1</span><span class="w">
</span><span class="p">{</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">        
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="m">1L</span><span class="p">)</span><span class="w"> 
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="m">3.124</span><span class="p">)</span><span class="w">        
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="s2">"R is awesome"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "TRUE is a vector of type logical and length 1"
## [1] "1L is a vector of type integer and length 1"
## [1] "3.124 is a vector of type double and length 1"
## [1] "'R is awesome' is a vector of type character and length 1"</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># constants are also vectors of length 1</span><span class="w">
</span><span class="p">{</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">NA</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">NA_integer_</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">NA_real_</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">NA_character_</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">NaN</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="kc">Inf</span><span class="p">)</span><span class="w">
        </span><span class="n">print_atom_info</span><span class="p">(</span><span class="o">-</span><span class="kc">Inf</span><span class="p">)</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] "NA is a vector of type logical and length 1"
## [1] "NA_integer_ is a vector of type integer and length 1"
## [1] "NA_real_ is a vector of type double and length 1"
## [1] "NA_character_ is a vector of type character and length 1"
## [1] "NaN is a vector of type double and length 1"
## [1] "Inf is a vector of type double and length 1"
## [1] "-Inf is a vector of type double and length 1"</code></pre></figure>

<h2 id="length-n-vectors-n--1">Length-n vectors, n &gt; 1</h2>

<p>The syntax for a vector with at least 2 values is <code class="language-plaintext highlighter-rouge">c(v1, v2, ..., vn)</code>. (Now we know each value <code class="language-plaintext highlighter-rouge">v</code> is itself a length-1 vector, we’ll stop repeating this and simply treat them as if they are single atomic values.) We can make a vector with <code class="language-plaintext highlighter-rouge">c(e1, ..., en)</code> where each expression<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <code class="language-plaintext highlighter-rouge">e</code> is evaluated to a value. In practice, it’s more common to make a vector with <code class="language-plaintext highlighter-rouge">c(e1, e2)</code>, called “<code class="language-plaintext highlighter-rouge">e1</code> combined with <code class="language-plaintext highlighter-rouge">e2</code>,” where <code class="language-plaintext highlighter-rouge">e1</code> evaluates to a “vector of type <code class="language-plaintext highlighter-rouge">t</code>” and <code class="language-plaintext highlighter-rouge">e2</code> evaluates to another “vector of type <code class="language-plaintext highlighter-rouge">t</code>.” The result is a new vector that starts with the elements in <code class="language-plaintext highlighter-rouge">e1</code> followed by the elements in <code class="language-plaintext highlighter-rouge">e2</code>. When <code class="language-plaintext highlighter-rouge">e1</code> evaluates to a single value, borrowing the word “cons” from FP (Functional Programming), <code class="language-plaintext highlighter-rouge">c(e1, e2)</code> can also be called “<code class="language-plaintext highlighter-rouge">e1</code> consed onto <code class="language-plaintext highlighter-rouge">e2</code>.” The result is then a new vector that starts with the value of <code class="language-plaintext highlighter-rouge">e1</code> followed by the elements in <code class="language-plaintext highlighter-rouge">e2</code>.</p>

<h2 id="how-to-use-vectors">How to use vectors</h2>

<p>One goal of this RFP (R Functional Programming) series is to learn the fundamental ideas of functional programming using R<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. These ideas are very powerful, and the first one we’ll look at is the emphasis on recursion. As we’ll see, because of recursion, all we need, when working with vectors, are three basic operations:</p>

<ol>
  <li>Check if a vector is empty.</li>
  <li>Get the first element of a vector, raising an exception if the vector is empty.</li>
  <li>Get the tail of a vector without its first element, raising an exception if the vector is empty.</li>
</ol>

<p>And we can solve almost all problems that involve one or more vectors. But R doesn’t provide these basic operations perfectly out of the box. Instead, we have to write our own functions for them.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Check if a vector is empty. Returns TRUE if it is, FALSE otherwise.</span><span class="w">
</span><span class="n">is_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="nf">length</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the first element of a vector, raising an exception if the vector is empty.</span><span class="w">
</span><span class="n">hd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Vector is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="c1"># Get the tail of a vector without its first element, raising an exception if the vector is empty.</span><span class="w">
</span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># xs: a vector of any type</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Vector is empty."</span><span class="p">)</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">xs</span><span class="p">[</span><span class="m">-1</span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Having defined <code class="language-plaintext highlighter-rouge">is_empty()</code>, <code class="language-plaintext highlighter-rouge">hd()</code> and <code class="language-plaintext highlighter-rouge">tl()</code>, we can use them inside of recursive functions to perform complex operations on vectors. For example, we can sum up all values in an integer or numeric vector.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">sum_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># xs: an interger or numeric vector</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="m">0</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sum_vec</span><span class="p">(</span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="p">{</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">sum_vec</span><span class="p">(</span><span class="n">integer</span><span class="p">()))</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">sum_vec</span><span class="p">(</span><span class="m">1</span><span class="p">))</span><span class="w">
        </span><span class="n">print</span><span class="p">(</span><span class="n">sum_vec</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">))</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 0
## [1] 1
## [1] 55</code></pre></figure>

<p>We can also count from n down to 0 and return a vector with integer elements of n, n-1, …, 0.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">countdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c1"># n: a positive integer</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="n">integer</span><span class="p">()</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">countdown</span><span class="p">(</span><span class="n">n</span><span class="m">-1</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="n">countdown</span><span class="p">(</span><span class="m">10</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">##  [1] 10  9  8  7  6  5  4  3  2  1</code></pre></figure>

<p>Both <code class="language-plaintext highlighter-rouge">sum_vec()</code> and <code class="language-plaintext highlighter-rouge">countdown()</code> are recursive functions. A recursive function (or recursion) has a base case and a recursive case. For example, in <code class="language-plaintext highlighter-rouge">sum_vec()</code>, the base case is when the input vector is empty, and the result is just 0. When the vector is not empty, we enter the recursive case and get the result by adding its first element and the result of calling <code class="language-plaintext highlighter-rouge">sum_vec()</code> on its tail, which is also a vector. In <code class="language-plaintext highlighter-rouge">countdown()</code>, the base case is when n is 0, and the result is an empty integer vector. We enter the recursive case as long as n &gt; 0, and get the result by consing n onto the result of calling <code class="language-plaintext highlighter-rouge">countdown()</code> on n-1. In general, when thinking about recursion, we want to reason as follows:</p>

<ol>
  <li>What’s the base case? What should the result be under the base case?</li>
  <li>What’s the recursive case? How can the result be expressed in terms of the result for the sub-problem (for example, the rest of the vector or n-1).</li>
</ol>

<p>It is not a coincidence that we’ve written both <code class="language-plaintext highlighter-rouge">sum_vec()</code> and <code class="language-plaintext highlighter-rouge">countdown()</code> recursively. From the FP perspective, recursion is almost always THE approach when processing or building vectors because a vector can grow or shrink and its length isn’t needed for recursion to work. The alternative approach of using loops and assignment statements is inferior and discouraged. To learn why, google “loops discouraged in functional programming.” There are many good and thorough discussions about this topic on the internet. Here I’ll just give a superficial but important reason: it takes more lines to write the same <code class="language-plaintext highlighter-rouge">sum_vec()</code> using a while-loop. We’ll also need extra things that recursion doesn’t, namely, local variables and assignment statements.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">sum_vec_while_loop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">tot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># need a local variable to hold the result</span><span class="w">
        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="c1"># as long as the loop doesn't end,</span><span class="w">
                </span><span class="n">tot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tot</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hd</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="c1">#   need to keep copy-n-modify tot, and </span><span class="w">
                </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tl</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w">        </span><span class="c1">#   need to keep copy-n-modify xs.</span><span class="w">
        </span><span class="p">}</span><span class="w">
        </span><span class="n">tot</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>The word ‘expression’ here is being used in the sense of expressions in any programming language or mathematical expressions. Do NOT confuse it with the R expression object. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>R is a functional programming language in its core. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[The simplest data structure in R is the vector. A vector is one dimensional and can be imagined as a sequence of blocks containing values:]]></summary></entry><entry><title type="html">Accurate Calculation of Years between Dates in R</title><link href="http://localhost:4000/r/accurate-calculation-of-years-between-dates/" rel="alternate" type="text/html" title="Accurate Calculation of Years between Dates in R" /><published>2018-12-04T00:00:00+09:00</published><updated>2018-12-04T00:00:00+09:00</updated><id>http://localhost:4000/r/accurate-calculation-of-years-between-dates</id><content type="html" xml:base="http://localhost:4000/r/accurate-calculation-of-years-between-dates/"><![CDATA[<p>When doing feature engineering, it’s common to turn dates into numbers by calculating the time differences. For example, given date of birth, you may want to calculate age. Given sign up date and churn date, you may want to calculate the days to churn. Depending on the situation, sometimes you want the time difference in years, and sometimes you want it in months, weeks or days; sometimes you want the years/months/weeks rounded to whole numbers, and other times you may want to keep the decimal points for more accuracy. For example, suppose we want to calculate the number of years (without rounding) between two dates, there’re 3 ways we can go about it:</p>

<ol>
  <li>Calculate the number of days in between using <code class="language-plaintext highlighter-rouge">difftime(end_date, start_date)</code>, and divide it by 365. But this will be not accurate as some years have 366 days.</li>
  <li>Calcualte the number of weeks in between using <code class="language-plaintext highlighter-rouge">difftime(end_date, start_date, unit = "weeks")</code> and divide it by 52.25. Some people believe by using 52.25 instead of 52, it will solve the 365 or 366 days issue. But this is not true and the results obtained are still not accurate as we’ll show below.</li>
  <li>Calculate the number of days in between using <code class="language-plaintext highlighter-rouge">difftime(end_date, start_date)</code>, and feed it into the <code class="language-plaintext highlighter-rouge">lubridate::time_length()</code> function while specifying the 2nd argument as “years”. This turns out to give accurate results.</li>
</ol>

<p>As an example, say we want to calculate the number of years between “2012-03-01” and “2017-03-01”. Obviously, it has to be at least 5 years. But method 2 gives 4.992, while method 3 gives 5.002.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"2012-03-01"</span><span class="p">)</span><span class="w">
</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"2017-03-01"</span><span class="p">)</span><span class="w">

</span><span class="c1"># method 2</span><span class="w">
</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">difftime</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"weeks"</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">52.25</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 4.992481</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># method 3</span><span class="w">
</span><span class="n">lubridate</span><span class="o">::</span><span class="n">time_length</span><span class="p">(</span><span class="n">difftime</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">),</span><span class="w"> </span><span class="s2">"years"</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 5.00274</code></pre></figure>

<p>As another example, say we want to calculate the number of years between “1948-12-07” and “2018-12-07”. Obviously, it has to be at least 70 years. But method 2 gives 69.902, while method 3 gives 70.047.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"1948-12-07"</span><span class="p">)</span><span class="w">
</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"2018-12-07"</span><span class="p">)</span><span class="w">

</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">difftime</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">unit</span><span class="o">=</span><span class="s2">"weeks"</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">52.25</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 69.90294</code></pre></figure>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">lubridate</span><span class="o">::</span><span class="n">time_length</span><span class="p">(</span><span class="n">difftime</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">),</span><span class="w"> </span><span class="s2">"years"</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">## [1] 70.04658</code></pre></figure>

<p>For more detailed discussion, refer to <a href="https://stackoverflow.com/questions/15569333/get-date-difference-in-years-floating-point">this discussion on stackoverflow</a>.</p>]]></content><author><name>Guangming Lang</name><email>gmlang@cabaceo.com</email></author><category term="r" /><summary type="html"><![CDATA[When doing feature engineering, it’s common to turn dates into numbers by calculating the time differences. For example, given date of birth, you may want to calculate age. Given sign up date and churn date, you may want to calculate the days to churn. Depending on the situation, sometimes you want the time difference in years, and sometimes you want it in months, weeks or days; sometimes you want the years/months/weeks rounded to whole numbers, and other times you may want to keep the decimal points for more accuracy. For example, suppose we want to calculate the number of years (without rounding) between two dates, there’re 3 ways we can go about it:]]></summary></entry></feed>